#include <algorithm>
#include <cctype>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <string>
#include <vector>

// -----------------------------------------------------------------------------
// 辅助函数
// -----------------------------------------------------------------------------

std::string get_arg(const std::vector<std::string>& args, const std::string& key)
{
  for (size_t i = 0; i < args.size(); ++i)
  {
    if (args[i] == key && i + 1 < args.size())
    {
      return args[i + 1];
    }
  }
  return "";
}

std::string get_basename(const std::string& path)
{
  size_t last_slash = path.find_last_of("/\\");
  if (last_slash != std::string::npos)
  {
    return path.substr(last_slash + 1);
  }
  return path;
}

std::string to_upper(std::string s)
{
  std::transform(s.begin(), s.end(), s.begin(),
                 [](unsigned char c) { return std::toupper(c); });
  return s;
}

std::string sanitize_for_c_identifier(const std::string& name)
{
  std::string result;
  result.reserve(name.size());
  for (char c : name)
  {
    if (std::isalnum(static_cast<unsigned char>(c)))
    {
      result.push_back(c);
    }
    else
    {
      result.push_back('_');
    }
  }
  if (result.empty()) return "_resource";
  if (std::isdigit(static_cast<unsigned char>(result[0]))) return "_" + result;
  return result;
}

// -----------------------------------------------------------------------------
// 主逻辑
// -----------------------------------------------------------------------------

int main(int argc, char* argv[])
{
  std::vector<std::string> args(argv, argv + argc);

  std::string input_path = get_arg(args, "--input");
  std::string output_h_path = get_arg(args, "--output_h");
  std::string output_cpp_path = get_arg(args, "--output_cpp");
  std::string resource_name = get_arg(args, "--resource_name");
  std::string data_type_arg = get_arg(args, "--data_type");

  if (data_type_arg.empty()) data_type_arg = "uchar";

  if (input_path.empty() || output_h_path.empty() || output_cpp_path.empty() || resource_name.empty())
  {
    std::cerr << "Error: Missing required arguments." << std::endl;
    return 1;
  }

  std::string c_var_name = sanitize_for_c_identifier(resource_name);
  std::string header_basename = get_basename(output_h_path);
  std::string include_guard = "__" + to_upper(sanitize_for_c_identifier(resource_name)) + "_H__";

  // 确定 C 类型
  std::string c_type_str;
  if (data_type_arg == "char") c_type_str = "char";
  else if (data_type_arg == "uint") c_type_str = "unsigned int";
  else c_type_str = "unsigned char";

  // 读取数据
  std::ifstream input(input_path, std::ios::binary);
  if (!input)
  {
    std::cerr << "Error reading input file: " << input_path << std::endl;
    return 1;
  }
  std::vector<unsigned char> data(
    (std::istreambuf_iterator<char>(input)),
    (std::istreambuf_iterator<char>())
  );
  input.close();

  // -------------------------------------------------------------------------
  // 1. 生成头文件 (.h)
  // -------------------------------------------------------------------------
  std::ofstream out_h(output_h_path);
  if (!out_h)
  {
    std::cerr << "Error writing header file." << std::endl;
    return 1;
  }

  out_h << "// Generated by bin_to_cc (C++11 compliant)\n";
  out_h << "#ifndef " << include_guard << "\n";
  out_h << "#define " << include_guard << "\n\n";
  out_h << "#include <stddef.h>\n\n";

  // C 兼容部分
  out_h << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";

  out_h << "typedef struct {\n";
  out_h << "    const char* name;\n";
  out_h << "    size_t size;\n";
  out_h << "    const " << c_type_str << "* data;\n";
  out_h << "} __ResourceData_" << c_var_name << ";\n\n";

  out_h << "extern const __ResourceData_" << c_var_name << " " << c_var_name << ";\n\n";

  out_h << "#ifdef __cplusplus\n} // extern \"C\"\n";

  // ------------------------------------------------------------
  // C++ 增强部分 (Zero-Copy 包装器)
  // ------------------------------------------------------------
  out_h << "\n// C++11 Zero-Copy View Wrapper\n";
  out_h << "#include <vector>\n";
  out_h << "#include <string>\n\n";

  out_h << "struct " << c_var_name << "_view_t {\n";
  out_h << "    using value_type = " << c_type_str << ";\n";
  out_h << "    using const_iterator = const value_type*;\n\n";

  // 1. 标准容器接口 (零拷贝)
  out_h << "    const_iterator begin() const { return " << c_var_name << ".data; }\n";
  out_h << "    const_iterator end() const { return " << c_var_name << ".data + " << c_var_name << ".size; }\n";
  out_h << "    size_t size() const { return " << c_var_name << ".size; }\n";
  out_h << "    const value_type* data() const { return " << c_var_name << ".data; }\n";
  out_h << "    const value_type& operator[](size_t i) const { return " << c_var_name << ".data[i]; }\n\n";

  // 2. 转换为 std::string (如果需要，会拷贝)
  out_h << "    std::string as_string() const {\n";
  out_h << "        return std::string(reinterpret_cast<const char*>(begin()), size());\n";
  out_h << "    }\n\n";

  // 3. 转换为 std::vector (显式拷贝)
  out_h << "    std::vector<value_type> as_vector() const {\n";
  out_h << "        return std::vector<value_type>(begin(), end());\n";
  out_h << "    }\n";
  out_h << "};\n\n";

  // 定义一个静态常量对象，方便直接使用
  // 注意：在头文件中定义 static 对象会导致每个 include 的文件都有一份副本
  // 更好的方式是定义类型，让用户实例化，或者使用 constexpr (如果C++17的话 inline 变量最好)
  // 为了兼容性和易用性，这里只定义类型，并提供一个全局引用的宏或者简单的实例化建议
  out_h << "static const " << c_var_name << "_view_t " << c_var_name << "_cpp = {};\n\n";

  out_h << "#endif // __cplusplus\n\n";
  out_h << "#endif // " << include_guard << "\n";
  out_h.close();

  // -------------------------------------------------------------------------
  // 2. 生成源文件 (.cpp)
  // -------------------------------------------------------------------------
  std::ofstream out_cpp(output_cpp_path);
  if (!out_cpp)
  {
    std::cerr << "Error writing source file." << std::endl;
    return 1;
  }

  out_cpp << "// Generated by bin_to_cc\n";
  out_cpp << "#include \"" << header_basename << "\"\n\n";
  out_cpp << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";

  out_cpp << "static const " << c_type_str << " " << c_var_name << "_data[] = {";
  out_cpp << std::hex << std::setfill('0');

  if (data_type_arg == "uint")
  {
    size_t total_bytes = data.size();
    for (size_t i = 0; i < total_bytes; i += 4)
    {
      if ((i / 4) % 8 == 0) out_cpp << "\n    ";
      unsigned int value = 0;
      unsigned char b0 = (i < total_bytes) ? data[i] : 0;
      unsigned char b1 = (i + 1 < total_bytes) ? data[i + 1] : 0;
      unsigned char b2 = (i + 2 < total_bytes) ? data[i + 2] : 0;
      unsigned char b3 = (i + 3 < total_bytes) ? data[i + 3] : 0;
      value = (static_cast<unsigned int>(b3) << 24) | (static_cast<unsigned int>(b2) << 16) |
        (static_cast<unsigned int>(b1) << 8) | (static_cast<unsigned int>(b0));
      out_cpp << "0x" << std::setw(8) << value << "u, ";
    }
  }
  else
  {
    if (data_type_arg == "char") out_cpp << std::dec;
    for (size_t i = 0; i < data.size(); ++i)
    {
      if (i % 12 == 0) out_cpp << "\n    ";
      if (data_type_arg == "char") out_cpp << static_cast<int>(static_cast<char>(data[i])) << ", ";
      else out_cpp << "0x" << std::setw(2) << static_cast<int>(data[i]) << ", ";
    }
  }

  out_cpp << "\n};\n\n";
  out_cpp << std::dec;

  out_cpp << "const __ResourceData_" << c_var_name << " " << c_var_name << " = {\n";
  out_cpp << "    \"" << resource_name << "\",\n";
  out_cpp << "    " << data.size() << ",\n";
  out_cpp << "    " << c_var_name << "_data\n";
  out_cpp << "};\n\n";

  out_cpp << "#ifdef __cplusplus\n} // extern \"C\"\n#endif\n";
  out_cpp.close();

  // -------------------------------------------------------------------------
  // 提示输出
  // -------------------------------------------------------------------------
  std::cout << "// Usage Hint:" << std::endl;
  std::cout << "#include \"" << header_basename << "\"" << std::endl;
  std::cout << "// 1. C Style:" << std::endl;
  std::cout << "extern const __ResourceData_" << c_var_name << " " << c_var_name << ";" << std::endl;
  std::cout << "// 2. C++ STL Style (Zero Copy):" << std::endl;
  std::cout << "auto& res = " << c_var_name << "_cpp; // Use like std::vector" << std::endl;
  std::cout << "// for (auto b : res) { ... }" << std::endl;
  std::cout << "// std::vector<uchar> v = res.as_vector(); // Copied" << std::endl;

  return 0;
}
